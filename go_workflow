In Go, it is not possible to isolate the dependencies for different projects in the same way that you can with Python virtual environments.

In Go, all of the dependencies for all of your projects will be stored in the src directory within GOPATH, and they will be organized by their import paths.

This means that if you are working on multiple Go projects that have overlapping dependencies, 
it is possible that you may end up with multiple versions of the same dependency installed in the src directory. However, 
Go modules, which were introduced in Go 1.11, provide a way to manage dependencies in a more flexible and reliable way,
and they can help to avoid conflicts between different versions of the same dependency.

Go modules allow you to specify the dependencies for each project in a go.mod file, which is stored in the root directory of the project.

The go.mod file specifies the import paths of the packages that are part of the module, as well as the versions of those packages and any additional dependencies that the module requires. 
By using Go modules, you can isolate the dependencies for each project and avoid conflicts between different projects.

While Go does not have a local node_modules equivalent or a system like Python virtual environments,
it does provide tools and features that can help you manage dependencies for your projects.


So What I understood is Here -------->
( I will be comparing the go workflow with node.js here so if you know that it will be a plus point)

First lets understand some key terminologies in the Go environment --->
GOROOT ----> The directory where the Go installation is located, So it is an Environment variable
When you download archived file from official repo of Go, as the package manager is not involved, this env is not set
You need to set it to the folder which contains the extracted go installation which has directories like bin/ src/ pkg/ etc.
Then, you need to add the folder $GOROOT/bin/ to the PATH env as well to call go from anywhere as it is located there
So when you call go to execute any go code, the PATH env will call the appropriate Go executable from $GOROOT/bin/ which is $GOROOT/bin/go
Go compiler optionally requires This $GOROOT env variable to know where to look for system level packages like "fmt", "net" etc.
Optionally because anyway it will search relatively to its own path to look for the system packages as it knows it will be itself inside the 
installation directory right :)
Then, As you have installed without package manager and nothing is set, you compulsorily need to set the env variable "GOPATH" as your workspace
This is mostly user specific and should be set something like /home/foo_user/go/
When you download with package manager or on Windows this env variable "GOPATH" is automatically created and the directory go inside your home folder 
i.e /home/foo_user/go is automatically created ad it is set to that 
Go optionally requires GOBIN env which is nothing but $GOPATH/bin
that means when we created /home/foo_user/go and set it as value of GOPATH, inside that there will be a folder bin/ which is created automatically in case
of above mentioned scenarios (you do not require it directly as will not be working inside this GOPATH directory any way :) )

So what next?
Well here Go gets interesting !

When you want to create a project in any stack, what you do you do ?
Well you create an empty directory in your home-directory like "/home/foo_user/some_project"

We are going to do exactly that !

suppose I created a folder like /home/foo_user/go_project  where /home/foo_user/go already exists(required)

and You start working there.
suppose I create a simple file called file.go in /home/foo_user/go_project and use standerd libraries which are already available in the go installtion,
then you can run that file directly as go run ./file.go  (assuming you are in same directory)
Then it is fine and ok 

But when you require a package that is hosted on github.com/some_user/some_package/
Then You might think you just need the command " go get ...." to download it right? 
well here it is the actual process.

Go from version xxxx, has stopped downloading dependencies without listing it in the project's go.mod file 
This is important as it forces you to have the go.mod file in which whatever you download with "go get...." will be listed


So you need to initialize that project directory with the command "go mod init github.com/foo_user/some_name" 
the string after init is your module name
don't worry about that right now.
It then creates and empty go.mod file in that project directory (remember, empty)
Then when you want the required package supppose "github.com/some_user/some_package"
what you write is "go get github.com/some_user/some_package"
BUT REMEMBER you write this while being in the project's directory where go.mod is there

By this, go will first look for go.mod file in the current directoy (the directory from which you ran the command) then if it finds go.mod file,
it is going to first locate that file by converting it into the URL i.e https://github.com/some_user/some_package and sees if some package named
that exists over there or not, then it downloads the package


WAIT where does it download?

Here GOPATH comes into play .

go get command downloads the package from the URL into the $GOPATH/src/ directory by recreating the URL structure 
i.e. what the above "go get..." command will do is that it will reacreate the path that is,

$GOPATH/src/github.com/some_user/some_package/ and then whatever that "some_package" contains, it will download over there.

After successfull download, it is going to update the go.mod file which is /home/foo_user/go_project/go.mod and add the "github.com/some_user/some_package"
into the require section 

That is all !

So this points out something;

Suppose you are working on 10 different go projects, then when you run "go get...." into those projects,
all the dependencies will get installed into the same directory which is

$GOPATH/src/


So, technically, you cannot separate dependencies in Go language for different projects


So in the context of node.js,
it is something like you have only one node_modules folder in you home folder, like /home/foo_user/node_modules 
and when you run "npm install" in any project which contains package.json and package-lock.json instead of creating separate folder in that 
project directory it is just going to install it over the single node_modules folder


And in the context of python,
It is something like you can't work with virtualenv, means all your dependencies will be installed in /usr/lib/pythonxxx/site-packages/



(Remember above two ones are just analogies that provide you understanding in the context of node.js and python by assuming that is
something like that was there)
































